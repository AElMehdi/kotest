package io.kotest.property

import io.kotest.property.gen.int
import io.kotest.property.gen.long
import kotlin.random.Random

/**
 * An [Arbitrary] is a type of [Argument] which generates two types of values: [edgecases] and [samples].
 *
 * Edge cases are values that are a common source of bugs. For example, a function using ints is
 * more likely to fail for common edge cases like zero, minus 1, positive 1, [Int.MAX_VALUE] and [Int.MIN_VALUE]
 * rather than random values like 965489. Therefore, edge cases can be included in sequences
 * generated by an arbitrary.
 *
 * Not all arbitraries will utilize edge cases. For example, if you define an integer generator
 * using a subset of the number space - say from 100 to 250,000 - then no edge cases are provided.
 *
 * Samples are chosen randomly from the sample space and are used to give a greater breadth to
 * the test cases. For example, in the case of a function using integers, these random values
 * could be from across the entire integer number line, or could be limited to a subset of ints
 * such as natural numbers or even numbers.
 */
interface Arbitrary<T> : Argument<T> {

   /**
    * Returns the values that are considered common edge case for the type.
    *
    * For example, for Strings this may include the empty string, a string with white space,
    * a string with unicode, and a string with non-printable characters.
    *
    * The result can be empty if for type T there are no common edge cases.
    *
    * @return the common edge cases for type T.
    */
   fun edgecases(): Iterable<T> = emptyList()

   /**
    * Returns a sequence of random sample values to be used for testing, along with an [RTree]
    * of reduced values used for shrinking.
    *
    * @param random the [Random] instance to be used for generating values. This random instance is
    * seeded using the seed provided to the test framework so that tests can be deterministically re-run.
    * Implementations should honour the random provider whenever possible.
    *
    * @return the random test values along with reduced values.
    */
   fun samples(random: Random): Sequence<ArgumentValue<T>>

   override fun values(random: Random): Sequence<ArgumentValue<T>> =
      edgecases().map { ArgumentValue(it, RTree.empty(it)) }.asSequence() + samples(random)

   companion object
}

/**
 * Returns a new [Arbitrary] with each value mapped using the supplied function.
 * The reduced values and edgecases will also be mapped.
 */
fun <T, U> Arbitrary<T>.map(f: (T) -> U): Arbitrary<U> = object : Arbitrary<U> {
   override fun edgecases(): Iterable<U> = this@map.edgecases().map(f)
   override fun samples(random: Random): Sequence<ArgumentValue<U>> =
      this@map.samples(random)
         .map { ArgumentValue(f(it.value), it.shrinks.map(f)) }
}

fun <T> Arbitrary<T>.filter(predicate: (T) -> Boolean): Arbitrary<T> = object : Arbitrary<T> {
   override fun edgecases(): Iterable<T> = this@filter.edgecases().filter(predicate)
   override fun samples(random: Random): Sequence<ArgumentValue<T>> =
      this@filter.samples(random)
         .filter { predicate(it.value) }
         .map { ArgumentValue(it.value, it.shrinks.filter(predicate)) }
}

@Suppress("UNCHECKED_CAST")
inline fun <reified T> Arbitrary.Companion.default(iterations: Int): Arbitrary<T> {
   val classname = T::class.simpleName ?: "<unknown>"
   return forClassName(classname, iterations) as Arbitrary<T>
}


fun forClassName(className: String, iterations: Int): Arbitrary<*> {
   return when (className) {
      "java.lang.Integer", "kotlin.Int", "Int" -> Gen.int().take(iterations)
      "java.lang.Long", "kotlin.Long", "Long" -> Gen.long().take(iterations)
      //"java.lang.Float", "kotlin.Float", "Float" -> Gen.float(iterations)
      //"java.lang.Double", "kotlin.Double", "Double" -> Gen.double(iterations)
      else -> throw IllegalArgumentException("Cannot infer generator for $className; specify generators explicitly")
   }
}
